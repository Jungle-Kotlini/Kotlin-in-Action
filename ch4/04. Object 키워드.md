object 키워드를 통해 클래스 정의 및 인스턴스 생성이 가능하다.
이 경우 클래스를 정의하는 동시에 인스턴스(객체)를 생성한다.
## 1. 객체 선언 : 싱글턴을 쉽게 만들기
- 객체지향 시스템에선 인스턴스가 하나만 있을 때 유용한 경우가 있다.
  - 프로젝트 내에서 해당 객체가 중복되면 안되는 경우 등등
- 자바의 경우
  - 클래스 생성자를 private로 제한하고 정적 필드에(static) 그 클래스의 유일한 객체를 저장하여 구현한다.
- 코틀린의 경우
  - 객체 선언 기능을 사용한다.
  - 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.
  - 회사 급여대장을 만드는 예시
  ```kotlin
  object Payroll {
    val allEmployees = arrayListOf<Person>()

    fun calculateSalary() {
      for (person in allEmployees) {
        ... // 코드 구현
      }
    }
  }
  ```
### 객체 선언의 특징
- object 키워드로 시작한다.
- 클래스를 정의, 그 클래스의 인스턴스를 만들어 변수에 저장하는 모든 작업을 단 한문장으로 처리한다.
- 생성자를 쓸 수 없다.
  - 프로퍼티, 메소드, 초기화 블록 등은 들어갈 수 있다.
  - 싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출없이 즉시 만들어진다 -> 즉 생성자 정의가 필요가 없다.
- 변수처럼, 객체 선언에 사용한 이름 뒤 마침표를 붙이면, 객체에 속한 메소드나 프로퍼티에 접근 가능하다.
```kotlin
Payroll.allEmployees.add(Person( ... ))
Payroll.calculateSalary()
```
- 클래스나 인터페이스를 상속 가능하다.
  - 프레임워크 사용을 위해 특정 인터페이스 구현 시, 구현 내부에 다른 상태가 필요하지 않은 경우 유용하다.
  ```kotlin
  object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(file1 : File, file2 : File) : Int {
      return file1.path.compareTo(file2.path, ignoreCase = true)
    }
  }
  ```
    - 결과

    ![image](https://github.com/user-attachments/assets/1c025b49-59f1-4105-aca7-7ac1d6833bb3)
    - Comparator 구현은 두 객체를 인자로 받아 그중 어느 객체가 더 큰지 알려주는 정수를 반환한다.
    - Comparator 안에는 데이터 저장이 필요가 없다.
      - 즉 어떤 클래스에 속한 객체를 비교할 때 사용하는 Comparator는 클래스마다 하나면 충분하다.
      - Comparator 인스턴스를 만드는 방법은 객체 선언이 가장 좋은 방법이다.
  - 일반 객체(클래스 인스턴스)를 사용 가능한 곳은 항상 싱글턴 객체를 사용 가능하다.
  ```kotlin
  val files = listOf(File("/z"), File("/a"))
  println(files.sortedWith(CaseInsensitiveFileComparator))
  ```
    - 전달받은 Comparator에 따라 리스트를 정렬하는 sortedWith 함수를 사용한다.
    - 결과

    ![image](https://github.com/user-attachments/assets/76bd830e-15bd-45e3-9468-91dddd518666)
> 싱글턴과 의존관계 주입
> - 의존관계가 별로 많지 않은 소규모 소프트웨어에서는 싱글턴, 객체선언이 유용할 수 있다.
> - 시스템을 구현하는 다양한 구성요소와 상호작용하는 대규모 컴포넌트에는 싱글턴이 적합하지 않다.
>   - 객체 생성을 제어할 방법이 없다.
>   - 생성자 파라미터를 지정할 수 없다.
>   - 단위 테스트 혹은 소프트웨어 시스템 설정이 달라질 때 객체를 대체하거나 객체의 의존관계를 바꿀 수 없다.
> - 이런 것이 필요할 경우 의존관계 주입 프레임워크와 코틀린 클래스를 함께 사용해야 한다.
- 클래스 안에서 객체 선언도 가능하다.
- 이 클래스의 인스턴스가 여러개라고, 안에 있는 객체도 여러개 생기는 게 아니라, 싱글턴으로 하나만 생긴다.
```kotlin
data class Person(val name : String) {
  object NameComparator : Comparator<Person> {
    override fun comapre (p1 : Person, p2 : Person): Int =
      p1.name.compareTo(p2.name)
  }
}

val persons = listOf(Person("Bob"), Person("Alice"))
println(persons.sortedWith(Person.NameComparator)) // 인스턴스의 함수를 쓰는 게 아니라 클래스의 함수를 사용한다.
```
- 결과

![image](https://github.com/user-attachments/assets/0c5945be-7d62-4e6d-b0f3-864cc341976d)

> 코틀린 객체를 자바에서 사용하기
> - 코틀린 객체 선언은 유일한 인스턴스에 대한 정적인 필드가 있는 자바 클래스로 컴파일된다.
>   - 이때 인스턴스 필드 이름은 항상 INSTANCE이다.
>   - 싱글턴 패턴을 자바에서 구현해도 정적인 INSTANCE 필드를 사용하면 된다.
>   ```java
>   CaseInsensitiveFileComparator.INSTANCE.compare(file1, file2);
>   ```
>   - 이때, INSTANCE 필드 타입은 CaseInsensitiveFileComparator다.
## 2. 동반 객체 : 팩토리 메소드와 정적 멤버가 들어갈 장소
  - 코틀린 클래스 안에는 정적인 멤버가 없다.
    - 자바 static 키워드를 지원 안한다.
    - 다음은 가능하다.
      - 패키지 수준의 최상위 함수 : 자바의 정적 메소드 역할을 거의 대신 할 수 있다.
      - 객체 선언 : 패키지 수준의 최상위 함수가 못하는 역할이나 정적 필드를 대신할 수 있다. 
  - 단, 최상위 함수는 private으로 표시된 클래스 비공개 멤버에 접근할 수 없다.
  - 클래스의 인스턴스와 관계없이 호출해야하지만 클래스 내부 정보에 접근해야 하는 함수가 필요할 때,
    - 클래스에 중첩된 객체 선언의 멤버 함수로 정의해야 한다.
    - 팩토리 메소드 등등
    - 실제로 실험해보면, class안에 class로 접근하면 에러가 발생하지만, inner class로 접근하면 가능하다.

    ![image](https://github.com/user-attachments/assets/f4e6edb2-5de8-4fd4-8b2b-ab962231bde9)
### 동반 객체 사용
- 클래스 안에 정의된 객체 중 하나에 companion이라는 특별한 표시를 붙히면 그 클래스의 동반 객체로 만들 수 있다.
  - 동반 객체의 프로퍼티, 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다.
    - 이때, 객체의 이름을 따로 지정할 필요 없다.
  - 동반 객체의 멤버를 사용하는 구문은 자바의 정적 메소드 호출이나 정적 필드 사용 구문과 같아진다.
  ```kotlin
  class A {
    private val aSecret = "A Secret"
    companion object {
      fun bar() {
        println("Companion Object called")
      }
    }
  }

  fun main() {
    A.bar()
  }
  ```
  - 결과

  ![image](https://github.com/user-attachments/assets/0e4f9020-57a6-425c-a629-bd15af2ef54f)
- 동반 객체는 private 생성자를 호출하기 좋은 위치다.
  - 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다.
    - 즉, 바깥쪽 클래스의 모든 private 멤버에 접근할 수 있다.
    - 즉, 동반 객체는 팩토리 패턴을 구현하기 가장 적합한 위치다.
    - 예시 : 부 생성자가 여럿 있는 클래스 정의하기
    ```kotlin
    class User {
      val nickname: String
      constructor(email: String) { // 부 생성자
        nickname = email.substringBefore('@')
      }
      constructor(facebookAccountId: Int) { // 부 생성자
        nickname = getFacebookName(facebookAccountId)
      }
    }
    ```
    - 다음과 같이 짜면 결과는 아래와 같다.
    ```kotlin
    fun main() {
      // 첫 번째 생성자: 이메일 기반
      val subscribingUser = User("bob@gmail.com")
      println(subscribingUser.nickname) // 출력: "bob"
  
      // 두 번째 생성자: Facebook Account ID 기반
      val facebookUser = User(4)
      println(facebookUser.nickname) // getFacebookName(4)의 반환 값 출력
    }
    ```
  - 위 방식을 바꿔, 클래스의 인스턴스를 생성하는 팩토리 메소드를 사용한다.
    - 예시 :
    ```kotlin
    class User private constructor(val nickname: String){ // 주 생성자를 비공개로 만든다.
      companion object {
        fun newSubscribingUser(email: String) =
            User(email.substringBefore('@'))
        fun newFacebookUser(accountId: Int) =
            User(getFacebookName(accountId))
      }
    }  
    ```
    - 결과는 아래와 같다.
    ```kotlin
    fun main() {
      // 첫 번째 생성자: 이메일 기반
      val subscribingUser = User.newSubscribingUser("bob@gmail.com")
     println(subscribingUser.nickname) // 출력: "bob"
  
      // 두 번째 생성자: Facebook Account ID 기반
      val facebookUser = User.newFacebookUser(4)
      println(facebookUser.nickname) // getFacebookName(4)의 반환 값 출력
    }
    ```
    - 장점
      - 팩토리 메소드 이름을 정할 수 있다.
      - 그 팩토리 메소드가 선언된 클래스의 하위 클래스 객체를 반환할 수도 있다.
        - SubscribingUser와 FacebookUser 클래스가 따로 존재한다면, 그때그때 필요에 따라 적당한 클래스의 객체를 반환할 수 있다.
      - 팩토리 메소드는 생성할 필요가 없는 객체를 생성하지 않을 수도 있다.
        - 이메일 주소별로 유일한 User 인스턴스를 만드는 경우, 이미 존재하는 인스턴스의 이메일을 받으면 캐시에 있는 기존 인스턴스를 반환할 수도 있다.
    - 단점
      - 클래스를 확장해야 하는 경우, 동반 객체 멤버를 하위 클래스에서 오버라이드 할 수 없다.
        - 이 경우 여러 생성자를 사용하는 편이 낫다.
    
    
    

  

    
    
