# 컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임

## 4.3.1 모든 클래스가 정의해야 하는 메서드
## 4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성

> `data` 변경자를 클래스 앞에 붙이면 필요한 메서드를 컴파일러가 자동으로 만들어준다.  
> 이를 데이터 클래스라고 칭함

```kotlin

// 사용방법
data class Client(val name: String, val postalCode: Int)

// 아래와 같이 직접 정의할 필요 없음
class Client(val name: String, val postalCode:Int){
    // [일반 클래스 출력값] Client@3941a79c
    override fun toString() = "Client(name=$name, postalCode=$postalCode)" // 데이터 클래스 출력값

    override fun equals(other:Any?): Boolean {
      if(other == null || other !is Client)
        return false
      return name == other.name && postalCode == other.postalCode
    }

    /**
    * JVM 언어에서는 "equals()가 tre를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야한다."
    * [e.g]
      println(clinet1 == clinet2) // true
      val group = hashSetOf(client1)
      println(group.contains(client2)) // 기대값: true
    */
    override fun hashCode(): Int = name.hashCode()*12 + postalCode


    // 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해줌
    fun copy(name: String = this.name, postalCode: Int = this.postalCode) = Client(name, postalCode)
}

fun main(){
    val client1 = Client("기존 이름", 1234)
    println(client1)  // Client(name=기존 이름, postalCode=1234)

    val copied = client1.copy("카리나")
    println(copied)  // Client(name=카리나, postalCode=1234)
}

```

> 더 알아보기 : `==` 역할?

- 코틀린에서 두 객체를 비교하는 기본적인 방법. 내부적으로 equals를 호출해서 객체를 비교함
- 따라서 equals를 오버라이드해서 `==` 사용할 수 있음

```kotlin
fun main(){
    val client1 = Client("김수암무", 1234)
    val client2 = Client("김수암무", 1234)

    println(client1.equals(client2))  // true
    println(client1 == client2)       // true
}
```
