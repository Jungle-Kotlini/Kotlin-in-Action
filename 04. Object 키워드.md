object 키워드를 통해 클래스 정의 및 인스턴스 생성이 가능하다.
이 경우 클래스를 정의하는 동시에 인스턴스(객체)를 생성한다.
## 객체 선언 : 싱글턴을 쉽게 만들기
- 객체지향 시스템에선 인스턴스가 하나만 있을 때 유용한 경우가 있다.
  - 프로젝트 내에서 해당 객체가 중복되면 안되는 경우 등등
- 자바의 경우
  - 클래스 생성자를 private로 제한하고 정적 필드에(static) 그 클래스의 유일한 객체를 저장하여 구현한다.
- 코틀린의 경우
  - 객체 선언 기능을 사용한다.
  - 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.
  - 회사 급여대장을 만드는 예시
  ```kotlin
  object Payroll {
    val allEmployees = arrayListOf<Person>()

    fun calculateSalary() {
      for (person in allEmployees) {
        ... // 코드 구현
      }
    }
  }
  ```
  ### 객체 선언의 특징
  - object 키워드로 시작한다.
  - 클래스를 정의, 그 클래스의 인스턴스를 만들어 변수에 저장하는 모든 작업을 단 한문장으로 처리한다.
  - 생성자를 쓸 수 없다.
    - 프로퍼티, 메소드, 초기화 블록 등은 들어갈 수 있다.
    - 싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출없이 즉시 만들어진다 -> 즉 생성자 정의가 필요가 없다.
  - 변수처럼, 객체 선언에 사용한 이름 뒤 마침표를 붙이면, 객체에 속한 메소드나 프로퍼티에 접근 가능하다.
  ```kotlin
  Payroll.allEmployees.add(Person( ... ))
  Payroll.calculateSalary()
  ```
  - 클래스나 인터페이스를 상속 가능하다.
    - 프레임워크 사용을 위해 특정 인터페이스 구현 시, 구현 내부에 다른 상태가 필요하지 않은 경우 유용하다.
    ```kotlin
    object CaseInsensitiveFileComparator : Comparator<File> {
      override fun compare(file1 : File, file2 : File) : Int {
        return file1.path.compareTo(file2.path, ignoreCase = true)
      }
    }
    ```
      - 결과

      ![image](https://github.com/user-attachments/assets/1c025b49-59f1-4105-aca7-7ac1d6833bb3)
      - Comparator 구현은 두 객체를 인자로 받아 그중 어느 객체가 더 큰지 알려주는 정수를 반환한다.
      - Comparator 안에는 데이터 저장이 필요가 없다.
        - 즉 어떤 클래스에 속한 객체를 비교할 때 사용하는 Comparator는 클래스마다 하나면 충분하다.
        - Comparator 인스턴스를 만드는 방법은 객체 선언이 가장 좋은 방법이다.
    - 일반 객체(클래스 인스턴스)를 사용 가능한 곳은 항상 싱글턴 객체를 사용 가능하다.
    ```
    val files = listOf(File("/z"), File("/a"))
    
