# 11.1 API에서 DSL로 (From APIs to DSLs)

## 11.1.1 도메인 특화 언어의 개념 (The Concept of Domain-Specific Languages)

**DSL**(도메인 특화 언어, Domain-Specific Language)는 특정 도메인에서의 작업을 용이하게 하기 위해 설계된 언어입니다. DSL은 일반적인 범용 프로그래밍 언어보다 특정 작업에 최적화된 언어로, 해당 작업에 필요하지 않은 기능을 생략하고 오히려 작업을 더욱 간결하게 수행할 수 있도록 설계됩니다.

예를 들어, **SQL**은 데이터베이스를 조작하는 데 사용되는 DSL이고, **정규 표현식**(Regular Expression)은 텍스트 매칭에 사용되는 DSL입니다. 이러한 언어들은 해당 도메인에서 매우 유용하지만, 이를 사용해 전체 애플리케이션을 작성하는 것은 적절하지 않습니다.

DSL은 **선언적**(Declarative) 성격을 가집니다. 선언적 언어는 원하는 결과만을 기술하며, 실행 방법은 해당 언어를 해석하는 엔진이 처리합니다. 반면, 범용 프로그래밍 언어는 **명령형**(Imperative) 성격을 가지고, 작업을 수행하는 정확한 단계를 기술합니다.

하지만 이러한 **외부 DSL**(External DSL)은 호스트 언어와 결합하기 어려운 경우가 있습니다. 이를 해결하기 위해 최근에는 **내부 DSL**(Internal DSL)이 인기를 얻고 있습니다.

---

## 11.1.2 내부 DSL (Internal DSLs)
**내부 DSL**은 외부 DSL과 달리, 범용 프로그래밍 언어의 문법을 활용하여 특정 작업을 위한 도메인 특화 문법을 작성하는 방법입니다. 즉, **내부 DSL**은 독립적인 언어가 아니라, 특정 도메인에서 코드를 더욱 표현력 있게 작성할 수 있는 방식으로 호스트 언어를 사용하는 패턴입니다.

Kotlin에서는 **Exposed 프레임워크**를 사용하여 데이터베이스 작업을 쉽게 처리할 수 있는 내부 DSL을 제공합니다.

### 예시: SQL과 Exposed를 사용한 쿼리 작성 비교

* **SQL**
```sql
SELECT Country.name, COUNT(Customer.id)
FROM Country
JOIN Customer ON Country.id = Customer.country_id
GROUP BY Country.name
ORDER BY COUNT(Customer.id) DESC
LIMIT 1
```

* **Kotlin의 Exposed**
```kotlin
(Country join Customer)
    .slice(Country.name, Count(Customer.id))
    .selectAll()
    .groupBy(Country.name)
    .orderBy(Count(Customer.id), isAsc = false)
    .limit(1)
```
두 방식 모두 동일한 쿼리를 작성하지만, Exposed를 사용한 Kotlin 코드가 더 읽기 쉽고, 코틀린 객체로 결과를 직접 받을 수 있다는 장점이 있습니다.

---

## 11.1.3 DSL의 구조 (Structure of DSLs)

DSL과 일반적인 API 간의 경계는 명확하지 않지만, DSL에서는 보통 **구조** 또는 **문법**이 중요합니다. 일반적인 API는 명령과 질의가 혼합된 형식이며, 각 메서드 호출은 독립적으로 동작합니다. 반면, DSL은 더 큰 구조 내에서 메서드 호출이 연속적으로 존재하며, 각 호출은 DSL 문법에 의해 연결됩니다.

Kotlin DSL에서는 주로 **람다 중첩**이나 **메서드 체이닝**을 통해 이러한 구조를 생성합니다. 이를 통해 함수 호출을 조합하여 더 복잡한 작업을 수행할 수 있습니다.

### 예시: Gradle의 종속성 정의

Gradle 빌드 스크립트에서 종속성을 정의하는 DSL 예시는 다음과 같습니다:

```kotlin
dependencies {
    compile("junit:junit:4.11")
    compile("com.google.inject:guice:4.1.0")
}
```
위의 코드에서는 `dependencies`라는 문맥을 한 번만 사용하고, 여러 `compile` 호출을 통해 종속성을 선언합니다. 동일한 작업을 일반적인 API로 수행하려면 더 많은 반복이 필요합니다:

```kotlin
project.dependencies.add("compile", "junit:junit:4.11")
project.dependencies.add("compile", "com.google.inject:guice:4.1.0")
```

---

## 11.1.4 HTML을 내부 DSL로 생성하기 (Building HTML with an Internal DSL)

Kotlin의 내부 DSL을 사용하여 HTML을 생성할 수 있습니다. 다음은 Kotlin 코드로 HTML 테이블을 생성하는 예시입니다.

```kotlin
fun createSimpleTable() = createHTML().table {
    tr {
        td { +"cell" }
    }
}
```
이 코드는 다음과 같은 HTML을 생성합니다:

```html
<table>
    <tr>
        <td>cell</td>
    </tr>
</table>
```
Kotlin DSL을 사용하여 HTML을 생성하는 주요 이점은 타입 안전성입니다. 예를 들어, `td` 태그는 `tr` 태그 안에서만 사용할 수 있으며, 잘못된 구조를 작성하면 컴파일 타임에 오류가 발생합니다. 또한, 일반적인 코드처럼 변수를 사용하여 동적으로 HTML 구조를 생성할 수 있습니다.

```kotlin
fun createAnotherTable() = createHTML().table {
    val numbers = mapOf(1 to "one", 2 to "two")
    for ((num, string) in numbers) {
        tr {
            td { +"$num" }
            td { +string }
        }
    }
}
```
이 코드는 다음과 같은 HTML을 생성합니다:

```html
<table>
    <tr><td>1</td><td>one</td></tr>
    <tr><td>2</td><td>two</td></tr>
</table>
```
DSL을 사용하면 코드 내에서 구조를 더 명확하고 직관적으로 표현할 수 있습니다.