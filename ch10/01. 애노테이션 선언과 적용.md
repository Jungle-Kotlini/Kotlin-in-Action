# 10.1 애노테이션과 리플렉션 (Annotations and Reflection)

애노테이션과 리플렉션은 런타임에 코드의 메타데이터를 처리하는 강력한 도구입니다. 애노테이션을 사용하여 메타데이터를 코드에 부여하고, 리플렉션을 통해 이러한 메타데이터를 런타임에 동적으로 접근하거나 조작할 수 있습니다. 이 장에서는 애노테이션을 선언하고 적용하는 방법, 애노테이션을 활용하여 코드를 확장하는 방법, 그리고 리플렉션을 통해 객체의 구조를 탐색하고 다루는 방법을 설명합니다.

---

## 10.1.1 애노테이션 적용 (Applying annotations)

애노테이션을 사용하면 클래스, 함수, 프로퍼티, 생성자 등 다양한 코드 요소에 메타데이터를 추가할 수 있습니다. Kotlin에서는 애노테이션을 Java와 거의 동일한 방식으로 사용합니다. 애노테이션은 클래스 또는 함수 위에 `@` 기호를 붙여 적용합니다.

### 예시 1: 기본 애노테이션 사용

다음은 JUnit 테스트에서 `@Test` 애노테이션을 사용하여 테스트 메서드를 정의하는 예입니다.

```kotlin
import org.junit.*

class MyTest {
    @Test fun testTrue() {
        Assert.assertTrue(true)
    }
}
```

### 예시 2: 애노테이션에 인자 전달

애노테이션에 인자를 전달하여 추가 정보를 지정할 수 있습니다. 예를 들어, `@Deprecated` 애노테이션은 API 사용 중단을 알리는 데 사용되며, 인자를 통해 대체할 코드 패턴을 제공할 수 있습니다.

```kotlin
@Deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)"))
fun remove(index: Int) { /*...*/ }
```
여기서 `Use removeAt(index) instead.`는 경고 메시지이고, `ReplaceWith("removeAt(index)")`는 대체할 코드입니다. 이 애노테이션은 `remove` 함수가 더 이상 사용되지 않으며, `removeAt(index)` 함수를 대신 사용해야 함을 알립니다.

---

## 10.1.2 애노테이션의 타겟 지정 (Annotation targets)

애노테이션은 여러 요소에 적용될 수 있으며, 때로는 애노테이션을 특정 위치에만 적용해야 할 때가 있습니다. 예를 들어, 클래스의 프로퍼티에 애노테이션을 적용할 때, 그것이 getter, setter 또는 프로퍼티 자체에 적용되어야 하는지를 명시적으로 지정할 수 있습니다. Kotlin에서는 `use-site target` 문법을 사용하여 이러한 세부 사항을 지정합니다.

### 예시: `use-site target` 사용

다음 코드는 `@get:Rule`을 사용하여 `TemporaryFolder` 애노테이션을 getter에만 적용하는 예입니다.

```kotlin
class HasTempFolder {
@get:Rule
val folder = TemporaryFolder()

    @Test
    fun testUsingTempFolder() {
        val createdFile = folder.newFile("myfile.txt")
        Assert.assertTrue(createdFile.exists())
    }
}
```
`@get:Rule`: 애노테이션을 getter 메서드에 적용합니다.
이를 통해 `folder` 프로퍼티의 getter 메서드에만 `@Rule` 애노테이션이 적용됩니다.
애노테이션 타겟의 종류
애노테이션 타겟은 다음과 같이 다양한 코드 요소에 적용될 수 있습니다:

* **property**: 프로퍼티 전체
* **field**: 프로퍼티의 backing field
* **get**: 프로퍼티의 getter
* **set**: 프로퍼티의 setter
* **param**: 생성자의 파라미터
* **setparam**: setter 메서드의 파라미터
* **delegate**: 위임 프로퍼티
예를 들어, setter에만 애노테이션을 적용하려면 다음과 같이 사용할 수 있습니다:

```kotlin
var name: String = "Kotlin"
    @set:Inject set
```
---

## 10.1.3 JSON 직렬화에서의 애노테이션 사용 (Using annotations to customize JSON serialization)

애노테이션은 객체를 JSON 형식으로 직렬화하거나 역직렬화할 때, 직렬화 규칙을 커스터마이징하는 데 사용할 수 있습니다. 예를 들어, 프로퍼티의 이름을 JSON 직렬화 시 다른 이름으로 바꾸거나, 특정 프로퍼티를 직렬화에서 제외할 수 있습니다.

### 예시: `@JsonName`과 `@JsonExclude` 사용
다음 코드는 `@JsonName` 애노테이션을 사용하여 `firstName` 프로퍼티를 JSON 직렬화 시 `alias`라는 이름으로 변경하고, `age` 프로퍼티를 직렬화에서 제외하는 방법을 보여줍니다.

```kotlin
data class Person(
    @JsonName("alias") val firstName: String,
    @JsonExclude val age: Int? = null
)
```
* `@JsonName("alias"):` `firstName`을 `alias`로 직렬화합니다.
* `@JsonExclude:` `age`는 직렬화하지 않습니다.

---

## 10.1.4 애노테이션 클래스 선언 (Declaring annotations)

Kotlin에서 애노테이션 클래스는 `annotation class` 키워드를 사용하여 선언합니다. 일반 클래스와 달리 애노테이션 클래스는 주로 메타데이터를 저장하는 용도로 사용되며, 일반적으로 본문을 가지지 않습니다.

### 기본 애노테이션 클래스 선언

```kotlin
annotation class JsonExclude
```
본문이 없는 간단한 애노테이션입니다. 이 애노테이션은 직렬화에서 특정 프로퍼티를 제외하는 데 사용될 수 있습니다.

### 파라미터가 있는 애노테이션 클래스 선언

애노테이션 클래스는 생성자를 사용하여 파라미터를 가질 수 있습니다. 다음은 @JsonName 애노테이션 클래스가 문자열 파라미터를 받는 예시입니다.

```kotlin
annotation class JsonName(val name: String)
```
애노테이션 파라미터는 일반적으로 상수 값을 받으며, 이러한 값은 애노테이션이 적용될 때 함께 제공됩니다.

---

## 10.1.5 메타 애노테이션 (Meta-annotations)

메타 애노테이션은 다른 애노테이션을 정의하는 데 사용됩니다. 메타 애노테이션을 사용하면 애노테이션이 적용될 수 있는 위치나 유지 범위를 제어할 수 있습니다. 대표적인 메타 애노테이션으로는 `@Target`과 `@Retention`이 있습니다.

### `@Target` 메타 애노테이션
`@Target`은 애노테이션이 적용될 수 있는 대상을 지정하는 데 사용됩니다. 예를 들어, 프로퍼티에만 적용되는 애노테이션을 만들고 싶다면 다음과 같이 `@Target`을 설정합니다.

```kotlin
@Target(AnnotationTarget.PROPERTY)
annotation class JsonExclude
```
여기서는 `@Target(AnnotationTarget.PROPERTY)`를 사용하여 `JsonExclude` 애노테이션이 프로퍼티에만 적용되도록 지정했습니다.

### `@Retention` 메타 애노테이션

`@Retention`은 애노테이션이 얼마나 오래 유지될지를 정의하는 데 사용됩니다. 기본적으로 애노테이션은 컴파일 타임에만 유지되지만, 런타임까지 유지되도록 설정할 수도 있습니다.

```kotlin
@Retention(AnnotationRetention.RUNTIME)
annotation class MyAnnotation
```
* `RUNTIME`: 런타임에도 애노테이션 정보가 유지됩니다. 리플렉션을 사용하여 런타임에 애노테이션 정보를 읽어올 수 있습니다.
* `BINARY`: 애노테이션이 바이너리 파일에만 포함되며, 리플렉션으로는 접근할 수 없습니다.
* `SOURCE`: 컴파일 시점에서만 유지되며, 컴파일 이후에는 애노테이션 정보가 사라집니다.

---

## 10.1.6 클래스 타입을 애노테이션 파라미터로 사용 (Classes as annotation parameters)

애노테이션 파라미터로 클래스 타입을 전달할 수 있습니다. 이때 Kotlin의 KClass를 사용하여 클래스 참조를 전달합니다. 클래스 참조를 통해 애노테이션이 특정 클래스와 관련된 동작을 수행할 수 있습니다.

### 예시: 클래스 타입을 애노테이션 파라미터로 사용
다음은 `@DeserializeInterface` 애노테이션을 사용하여 직렬화할 인터페이스 타입을 지정하는 예입니다.

```kotlin
annotation class DeserializeInterface(val targetClass: KClass<out Any>)
```
이 애노테이션은 인터페이스 타입을 파라미터로 받아, 해당 타입에 맞는 구체적인 클래스를 지정할 수 있도록 합니다.

```kotlin
@DeserializeInterface(MyImplementation::class)
interface MyInterface
```
여기서 `MyImplementation::class`는 `KClass`를 나타내며, 직렬화 시 `MyImplementation` 클래스를 사용하도록 지정합니다.

---

## 10.1.7 제네릭 클래스를 애노테이션 파라미터로 사용하기 (Generic classes as annotation parameters)

기본적으로, **JKid** 라이브러리는 비프리미티브(non-primitive) 타입의 프로퍼티들을 중첩된 객체(nested objects)로 직렬화합니다. 하지만 이 동작을 변경하고, 일부 값에 대해 직접적인 직렬화 로직을 제공할 수 있습니다. 이를 위해 **@CustomSerializer** 애노테이션을 사용하여 커스텀 직렬화 클래스를 참조할 수 있습니다. 커스텀 직렬화 클래스는 **ValueSerializer** 인터페이스를 구현해야 합니다.

```kotlin
interface ValueSerializer<T> {
    fun toJsonValue(value: T): Any?
    fun fromJsonValue(jsonValue: Any?): T
}
```
예를 들어, 날짜를 직렬화해야 한다고 가정해보겠습니다. 이 경우, **DateSerializer** 클래스를 작성하여 **ValueSerializer<Date>** 인터페이스를 구현할 수 있습니다. 다음과 같이 **Person** 클래스에서 이 직렬화 클래스를 사용할 수 있습니다.

```kotlin
data class Person(
    val name: String,
    @CustomSerializer(DateSerializer::class) val birthDate: Date
)
```
이 예시에서는 `birthDate`라는 **Date** 타입의 필드가 **DateSerializer**를 통해 커스터마이징된 직렬화 방식을 사용하게 됩니다.

애노테이션 클래스 선언하기
@CustomSerializer 애노테이션은 ValueSerializer 클래스에 대한 참조를 파라미터로 받습니다. 이때, ValueSerializer 클래스는 제네릭 타입이므로, 어떤 타입의 데이터를 직렬화할지 알 수 없으므로 모든 타입을 받을 수 있도록 **스타 프로젝션(Star Projection)**을 사용해야 합니다.

```kotlin
annotation class CustomSerializer(
    val serializerClass: KClass<out ValueSerializer<*>>
)
```
여기서 **KClass**는 Kotlin에서 Java의 **java.lang.Class**에 해당하는 타입입니다. `KClass<out ValueSerializer<*>>`는 제네릭 타입의 **ValueSerializer** 클래스의 서브타입만 참조하도록 제한됩니다. 이를 통해, 잘못된 클래스가 전달되는 것을 방지할 수 있습니다.

예를 들어, `@CustomSerializer(Date::class)`와 같이 **Date** 클래스가 직렬화기로 전달되는 것은 금지됩니다. **Date**는 **ValueSerializer** 인터페이스를 구현하지 않기 때문입니다.

이러한 패턴은 클래스 참조를 애노테이션 파라미터로 사용할 때 자주 사용됩니다. 클래스가 제네릭일 때도 이 패턴을 적용하여 안전한 코드를 작성할 수 있습니다.

